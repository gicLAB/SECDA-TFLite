import json5
import os

def sanitize_name(name):
    return name.replace(" | ", "_").replace(" ", "_").lower()

def generate_build_script():
	# Class representing a task to build one of the project's executables:
	class BuildTask:
		def __init__(self, name, command):
			self.name = name
			self.id = sanitize_name(name)
			self.command = command
			self.dependencies = []

		def __repr__(self):
			return f"BuildTask(name={self.name}, command={self.command}, dependencies={self.dependencies})"

	# Read the corresponding VS Code file:
	with open("../tensorflow/.vscode/tasks.json", "r") as file:
		tasks = json5.load(file)

	# Get the list of all build tasks available:
	builds = []
	for t in tasks["tasks"]:
		if t["type"] == "shell" and t["group"]["kind"] == "build":
			name = t["label"]
			command = t["command"]
			build = BuildTask(name, command)
			if "dependsOn" in t:
				for dep in t["dependsOn"]:
					build.dependencies.append(sanitize_name(dep))
			builds.append(build)

	# Build the bash script to execute the build tasks.
	bash_script = """#!/bin/bash

# This script was generated by generate_bash_tasks.py

"""
	
	# Define the varialbe parts of the script:
	# 1. Map of indeces to each of the tasks' functions:
	bash_script += "declare -a builds=(\n"
	for i, build in enumerate(builds):
		bash_script += f"\t\"{build.id}\"\n"
	bash_script += ")\n\n"
	# 2. One bash function per available task, with its "id" as the function name:
	for build in builds:
		bash_script += f"function {build.id}() {{\n"
		# 2.1 Execute the task's dependencies first, if any:
		for dep in build.dependencies:
			bash_script += f"\t{dep}\n"
		# 2.2 Print and execute the buid command:
		bash_script += f"\techo \"cd ../tensorflow && {build.command}; cd -\"\n"
		bash_script += f"\tcd ../tensorflow && {build.command}; cd -\n"
		bash_script += "}\n\n"
	# 3. Function to list the avialable tasks' names, for interactive use:
	bash_script += "function list_task_names() {\n"
	bash_script += "\techo \"Available build tasks by name:\"\n"
	for i, build in enumerate(builds):
		bash_script += f"\techo \" {(i + 1):2}.- {build.name}\"\n"
	bash_script += "\techo ""\n}\n\n"
	# 4. Function to list the avialable tasks' IDs, usable as arguments:
	bash_script += "function list_task_ids() {\n"
	bash_script += "\techo \"Available build tasks by ID:\"\n"
	for i, build in enumerate(builds):
		bash_script += f"\techo \" {(i + 1):2}.- {build.id}\"\n"

	# The rest of the script can be added as a single string, for readability:
	bash_script += """\techo ""
}

# Main execution function:
function execute_task() {
	# No arguments provided, list task names and choose interactively:
	if [ -z "$1" ]; then
		list_task_names
		echo -n "Index of the task to execute (1-$((${#builds[@]}))): "
		read index

		if ! [[ "$index" =~ ^[0-9]+$ ]] || [ "$index" -lt 1 ] || [ "$index" -gt ${#builds[@]} ]; then
			echo "Invalid task index provided. Exiting."
			exit 1
		fi
		index=$((index - 1))  # Convert to zero-based index
		task_name="${builds[$index]}"
	else
		# ID or index provided, translate to ID:
		if [[ "$1" =~ ^[0-9]+$ ]]; then
			if [ "$1" -lt 1 ] || [ "$1" -gt ${#builds[@]} ]; then
				echo "Invalid task index provided. Exiting."
				exit 1
			fi
			index=$(( $1 - 1 ))  # Convert to zero-based index
			task_name="${builds[$index]}"
		else
			task_name="$1"
		fi
	fi

	# Check if the task exists:
	if ! type "$task_name" &>/dev/null; then
		echo "Task '$task_name' not found. Exiting."
		exit 1
	fi

	echo "Executing build task '$task_name'..."
	"$task_name"
}

# Argument parsing and script execution:
# * [No arguments] List tasks and execute one interactively.
#   Calls execute_task with no arguments.
# * [-h] Print usage.
# * [-l] Print the list of IDs.
# * [task_id] Execute the specified task.
#   Calls execute_task with the specified task ID or index.
if [ -z "$1" ]; then
	execute_task
elif [ "$1" == "-h" ]; then
	echo "USAGE: $0 [task_id|task_index]"
	echo -n "\tIf no task_id or task_index is provided, a list of available build tasks is printed, "
	echo "and the user can run one interactively."
    echo ""
	echo "OPTIONS:"
	echo "\t$0 -h: Prints this help message."
	echo "\t$0 -l: Lists all the available task IDs."
elif [ "$1" == "-l" ]; then
	list_task_ids
else
	execute_task "$1"
fi
"""

	with open("build.sh", "w") as file:
		file.write(bash_script)
	os.chmod("build.sh", 0o755)


def generate_launch_script():
	# Class representing a task to launch any of the project's example executions:
	class LaunchTask:
		def __init__(self, name, command):
			self.name = name
			self.id = sanitize_name(name)
			self.command = command
			self.build_dependencies = []

		def __repr__(self):
			return f"LaunchTask(name={self.name}, command={self.command}, build_dependencies={self.build_dependencies})"

	# Read the corresponding VS Code file:
	with open("../tensorflow/.vscode/launch.json", "r") as file:
		launches = json5.load(file)

	# Get the list of all the launch tasks available:
	executions = []
	for l in launches["configurations"]:
		if l["request"] == "launch":
			name = l["name"]
			command = l["program"].replace("${workspaceFolder}/", "")
			for arg in l["args"]:
				command += " " + arg.replace("${workspaceFolder}/", "")
			launch = LaunchTask(name, command)
			if "preLaunchTask" in l:
				launch.build_dependencies.append(sanitize_name(l["preLaunchTask"]))
			executions.append(launch)

	# Build the bash script to execute the launch the example tasks.
	bash_script = """#!/bin/bash

# This script was generated by generate_bash_tasks.py

"""

	# Define the varialbe parts of the script:
	# 1. Map of indeces to each of the tasks' functions:
	bash_script += "declare -a executions=(\n"
	for i, execution in enumerate(executions):
		bash_script += f"\t\"{execution.id}\"\n"
	bash_script += ")\n\n"
	# 2. One bash function per available task, with its "id" as the function name:
	for execution in executions:
		bash_script += f"function {execution.id}() {{\n"
		# 2.1 Execute the task's build dependencies first, if any:
		for dep in execution.build_dependencies:
			bash_script += f"\t./build.sh {dep}\n"
		# 2.2 Print and execute the execution command:
		bash_script += f"\techo \"cd ../tensorflow && {execution.command}; cd -\"\n"
		bash_script += f"\tcd ../tensorflow && {execution.command}; cd -\n"
		bash_script += "}\n\n"
	# 3. Function to list the avialable tasks' names, for interactive use:
	bash_script += "function list_task_names() {\n"
	bash_script += "\techo \"Available launch tasks by name:\"\n"
	for i, execution in enumerate(executions):
		bash_script += f"\techo \" {(i + 1):2}.- {execution.name}\"\n"
	bash_script += "\techo ""\n}\n\n"
	# 4. Function to list the avialable tasks' IDs, usable as arguments:
	bash_script += "function list_task_ids() {\n"
	bash_script += "\techo \"Available launch tasks by ID:\"\n"
	for i, execution in enumerate(executions):
		bash_script += f"\techo \" {(i + 1):2}.- {execution.id}\"\n"

	# The rest of the script can be added as a single string, for readability:
	bash_script += """\techo ""
}

# Main execution function:
function execute_task() {
	# No arguments provided, list task names and choose interactively:
	if [ -z "$1" ]; then
		list_task_names
		echo -n "Index of the task to execute (1-$((${#executions[@]}))): "
		read index

		if ! [[ "$index" =~ ^[0-9]+$ ]] || [ "$index" -lt 1 ] || [ "$index" -gt ${#executions[@]} ]; then
			echo "Invalid task index provided. Exiting."
			exit 1
		fi
		index=$((index - 1))  # Convert to zero-based index
		task_name="${executions[$index]}"
	else
        echo "$1"
		# ID or index provided, translate to ID:
		if [[ "$1" =~ ^[0-9]+$ ]]; then
			if [ "$1" -lt 1 ] || [ "$1" -gt ${#executions[@]} ]; then
				echo "Invalid task index provided. Exiting."
				exit 1
			fi
			index=$(( $1 - 1 ))  # Convert to zero-based index
			task_name="${executions[$index]}"
		else
			task_name="$1"
		fi
	fi

	# Check if the task exists:
	if ! type "$task_name" &>/dev/null; then
		echo "Task '$task_name' not found. Exiting."
		exit 1
	fi

	echo "Executing launch task '$task_name'..."
	"$task_name"
}

# Argument parsing and script execution:
# * [No arguments] List tasks and execute one interactively.
#   Calls execute_task with no arguments.
# * [-h] Print usage.
# * [-l] Print the list of IDs.
# * [task_id] Execute the specified task.
#   Calls execute_task with the specified task ID or index.
if [ -z "$1" ]; then
	execute_task
elif [ "$1" == "-h" ]; then
	echo "USAGE: $0 [task_id|task_index]"
	echo -n "\tIf no task_id or task_index is provided, a list of available execution tasks is printed, "
	echo "and the user can run one interactively."
    echo ""
	echo "OPTIONS:"
	echo "\t$0 -h: Prints this help message."
	echo "\t$0 -l: Lists all the available task IDs."
elif [ "$1" == "-l" ]; then
	list_task_ids
else
    execute_task $1
fi
"""

	with open("launch.sh", "w") as file:
		file.write(bash_script)
	os.chmod("launch.sh", 0o755)

if __name__ == "__main__":
	print("Generating build.sh...")
	generate_build_script()
	print("Generating launch.sh...")
	generate_launch_script()
	print("Done.")
